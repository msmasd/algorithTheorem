# 알고리즘을 푸는 순서

## 1.1 듣기

문제 설명과 관련된 것이라면 어떤 정보든지 아주 집중해서 들어야한다. 최적 알고리즘을 설계하기 위해선 모든 정보가 필요할지도 모른다.

## 1.2. 예제

대부분의 예제들은 크기가 아주 작거나 특별한 사례인 경우가 많다. 직접 예제를 만들어서 디버깅하라. 직접 만든 예제가 특별한 경우인가? 혹은 충분히 큰 입력인가?

## 1.3 무식하게 풀기

우선은 빨리 무식한 방법(brute force)으로 풀길 바란다. 알고리즘의 효율을 높이려고 미리 애쓰지 말라. 아주 단순한 알고리즘 및 시간 복잡도를 먼저 말한 다음에 최적화를 시도하라. 아직은 코딩할 단계가 아니다.

## 1.4 최적화

BUD 최적화를 통해 무식하게 푼 방법을 개선하거나 아래의 방법을 시도한다.

* BUD최적화

1. 병목현상(Bottlenecks)
2. 불필요한 작업(Unnecessary work)
3. 중복되는 작업(Duplicated word)

* 간과한 부분이 있는지 생각해 보자. 보통의 경우 문제에서 언급된 정보를 모두 사용한다.
* 예제를 손으로 풀어 본 뒤 여러분의 사고 과정을 되짚어 보라. 어떻게 풀었는가?
* '잘못된' 방법으로 문제를 풀어 본 뒤 왜 알고리즘으 틀렸는지 생각해 보라. 여기서 발견된 문제들을 해결할 수 있는가?
* 시간과 공간의 비용-이익 관계를 고려하라. 이때 해시테이블이 특히 유용하다.

## 1.5 검토하기

최적의 해법을 찾았다면, 다시 한번 자세하게 검토해 보라. 코딩을 시작하기 전에 세밀한 부분을 제대로 알고 있는지 확인할 필요가 있다.


## 1.6 구현하기

여러분의 목적은 아름다운 코드를 작성하는 것이다. 시작부터 코드를 모듈화시키고 아름답지 않은 부분은 리펠터링해서 깔끔하게 만들라.

## 1.7 테스트

1. 개념적 테스트: 마치 코드 리뷰를 하듯이 자세하게 코드를 훑어보며 테스트하기
2. 특이하거나 표준적이지 않은 코드
3. 산술연산 혹은 null 노드와 같이 실수가 날 만한 부분
4. 작은 크기의 테스트들. 큰 크기의 테스트보다 빨리 검증 가능하고 효율적
5. 특이하거나 극단적인 입력

## 알고리즘 준비 방법

1. 직접 풀도록 노력하라: 문제를 직접 푸는 훈련을 해야한다. 답을 외우는 것은 의미가 없다. 문제를 풀 때는, 공간과 시간 효율에 대해서도 반드시 생각하라.
2. 코드를 종이에 적으라: 컴퓨터를 사용하면 문법 강조, 자동 완성, 디버거가 갖춰진 아주 편리한 환경에서 코딩을 할 수 있다. 하지만 종이에 코드를 작성하면 그런 도움없이 짜야한다. 실제 면접을 볼 때도 마찬가지니 종이에 코딩을 해보는것이 좋다. 종이에 코딩을 작성하면서 코드를 작성하고 수정하는데 오래 걸리는 환경에 적응해라.
3. 코드를 테스트해라: 종이위에서하는것이다. 일반적인것 뿐만 아니라, 기본 조건, 오류 발생 조건 등을 전부 테스트하라는 뜻이다.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라: 종이에 적으면서 실수했던 것들을 실수 목록을 만들어 실제 면접장에서는 같은 실수를 하지 않도록 주의한다.

## 알고 있어야 할 것들

|  <center>자료구조</center>   |  <center>알고리즘</center>                             |  <center>개념</center>    |
|:--------                    |:--------:                                             |--------:                  |
|연결 리스트(Linked Lists)     | <center>너비 우선 탐색(Breadth-First Search) </center> |비트 조작(Bit Manipulation) |
|트리, 트라이(Tries), 그래프   | <center>깊이 우선 탐색(Depth-First Search) </center>    |메모리(스택 vs 힙)          |
|스택 & 큐                    | <center>이진 탐색 </center>                             |재귀                       |
|힙(Heaps)                    | <center>병렬 정렬(Merge Sort) </center>                 |동적 프로그래밍             |
|Vector / ArrayList           | <center>퀵 정렬 </center>                               |big-O 시간 & 공간          |
|해시 테이블                   | <center>  </center>                                      |                           |
| || |


## 2의 승수 표

| <center>X</center> |  <center>2^x</center>  |<center>근사치</center> | <center>메모리 요구량</center> |
|:-------- |:-------- |:-------- |:-------- |
|7  | 128 | | |
|8  | 256 | | |
|10 | 1024 | 1,000(천) | 1K |
|16 | 65,536 |  | 64K |
|20 | 1,048,576 | 1,000,000(백만) | 1MB |
|30 | 1,073,741,824 | 1,000,000,000(십억) | 1GB |
|32 | 4,294,967,296 |  | 4GB |
|40 | 1,099,511,627,776 | 1,000,000,000,000(조) | 1TB |
